<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meus Lembretes</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Lembretes">
    <meta name="theme-color" content="#667eea">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 0.9em;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .card h2 {
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="datetime-local"],
        input[type="date"],
        input[type="time"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 7px 9px;
            border: 1px solid #ddd;
            border-radius: 7px;
            font-size: 15px;
            transition: border-color 0.3s;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 75px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .reminder-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: start;
        }

        .reminder-item.overdue {
            border-left-color: #e74c3c;
            background: #fee;
        }

        .reminder-content {
            flex: 1;
        }

        .reminder-title {
            font-weight: 600;
            font-size: 1em;
            color: #333;
            margin-bottom: 4px;
        }

        .reminder-time {
            color: #666;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .reminder-description {
            color: #888;
            font-size: 0.85em;
        }

        .reminder-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 14px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-delete {
            background: #e74c3c;
            color: white;
        }

        .btn-delete:hover {
            background: #c0392b;
        }

        .btn-complete {
            background: #27ae60;
            color: white;
        }

        .btn-complete:hover {
            background: #229954;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .tab {
            flex: 1;
            padding: 7px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab.active {
            background: white;
            color: #667eea;
        }

        .empty-state {
            text-align: center;
            padding: 25px;
            color: #999;
            font-size: 13px;
        }

        .recurrence-options {
            display: none;
            margin-top: 10px;
        }

        .recurrence-options.show {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-recurring {
            background: #3498db;
            color: white;
        }
        
        .badge-interval {
            background: #9b59b6;
            color: white;
        }

        .badge-complex {
            background: #e67e22;
            color: white;
        }

        .notification-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .alert-modal.show {
            display: flex;
        }

        .alert-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 420px;
            width: 90%;
            text-align: center;
            animation: bounceIn 0.5s ease;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .alert-icon {
            font-size: 60px;
            margin-bottom: 15px;
            animation: ring 1s ease infinite;
        }

        .alert-title {
            font-size: 22px;
            font-weight: 700;
            color: #333;
            margin-bottom: 12px;
        }

        .alert-description {
            font-size: 15px;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .alert-time {
            font-size: 14px;
            color: #999;
            margin-bottom: 20px;
        }

        .alert-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .alert-btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .alert-btn-dismiss {
            background: #95a5a6;
            color: white;
        }

        .alert-btn-dismiss:hover {
            background: #7f8c8d;
        }

        .alert-btn-complete {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .alert-btn-complete:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes ring {
            0%, 100% { transform: rotate(0deg); }
            10%, 30% { transform: rotate(-10deg); }
            20%, 40% { transform: rotate(10deg); }
        }
        
        .schedule-section {
            animation: fadeIn 0.3s ease;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-1px);
        }

        .schedules-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            background: #f8f9fa;
        }

        .schedule-item {
            background: white;
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid #667eea;
        }

        .schedule-item-info {
            flex: 1;
        }

        .schedule-item-time {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            font-size: 0.85em;
        }

        .schedule-item-type {
            font-size: 0.75em;
            color: #666;
        }

        .btn-remove-schedule {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-remove-schedule:hover {
            background: #c0392b;
        }

        .schedule-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .schedule-modal.show {
            display: flex;
        }

        .schedule-modal-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: bounceIn 0.5s ease;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .schedule-modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .schedule-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .schedule-modal-buttons button {
            flex: 1;
        }

        .empty-schedules {
            text-align: center;
            padding: 18px;
            color: #999;
            font-size: 13px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìù Meus Lembretes</h1>
            <p>Organize sua vida sem internet</p>
            <button id="installButton" class="btn" style="display: none; max-width: 300px; margin: 15px auto 0;">
                üì≤ Instalar App
            </button>
            <!-- BOT√ÉO DE DEBUG - ATIVADO -->
            <button onclick="debugReminders()" class="btn-secondary" style="max-width: 300px; margin: 10px auto 0;">
                üêõ Debug Lembretes
            </button>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('all')">Todos</button>
            <button class="tab" onclick="showTab('upcoming')">Pr√≥ximos</button>
            <button class="tab" onclick="showTab('overdue')">Atrasados</button>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 16px;">‚ûï Novo Lembrete</h2>
            
            <div class="input-group">
                <label>T√≠tulo do Lembrete</label>
                <input type="text" id="reminderTitle" placeholder="Ex: Ligar para o m√©dico">
            </div>

            <div class="input-group">
                <label>Tipo de Agendamento</label>
                <select id="scheduleType" onchange="toggleScheduleType()">
                    <option value="specific">Hor√°rio espec√≠fico</option>
                    <option value="interval">Intervalo</option>
                    <option value="complex">Complexo (m√∫ltiplos hor√°rios)</option>
                </select>
            </div>

            <!-- Hor√°rio Espec√≠fico -->
            <div class="schedule-section" id="specificTimeSection">
                <div class="input-group">
                    <label>Data e Hora</label>
                    <input type="datetime-local" id="reminderTime">
                </div>

                <div class="input-group">
                    <label>Repetir?</label>
                    <select id="recurrenceType" onchange="toggleRecurrenceOptions()">
                        <option value="none">N√£o repetir</option>
                        <option value="daily">Diariamente</option>
                        <option value="weekly">Semanalmente</option>
                        <option value="monthly">Mensalmente</option>
                    </select>
                </div>

                <div class="recurrence-options" id="recurrenceOptions">
                    <div class="input-group">
                        <label>Repetir at√© (opcional)</label>
                        <input type="date" id="recurrenceEnd">
                    </div>
                </div>
            </div>

            <!-- Intervalo -->
            <div class="schedule-section" id="intervalSection" style="display: none;">
                <div class="input-group">
                    <label>Intervalo</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="intervalValue" min="1" value="30" style="flex: 1;">
                        <select id="intervalUnit" style="flex: 1;">
                            <option value="minutes">Minutos</option>
                            <option value="hours">Horas</option>
                            <option value="days">Dias</option>
                        </select>
                    </div>
                </div>
                
                <div class="input-group">
                    <label>Come√ßar em</label>
                    <input type="datetime-local" id="intervalStart">
                </div>
                
                <div class="input-group">
                    <label>Terminar em (opcional)</label>
                    <input type="datetime-local" id="intervalEnd">
                </div>
            </div>

            <div class="input-group">
                <label>Descri√ß√£o (opcional)</label>
                <textarea id="reminderDescription" placeholder="Adicione detalhes sobre o lembrete..."></textarea>
            </div>

            <div class="input-group">
                <label>Hor√°rios Configurados</label>
                <div id="mainSchedulesList" class="schedules-list"></div>
            </div>

            <button type="button" class="btn-secondary" onclick="addScheduleToReminder()" style="margin-bottom: 9px;">
                ‚ûï Adicionar Hor√°rio
            </button>

            <button class="btn" onclick="addReminder()">Criar Lembrete</button>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 16px;">üìã Lista de Lembretes</h2>
            <div id="remindersList"></div>
        </div>
    </div>

    <div class="notification-badge" id="notificationBadge"></div>

    <div class="alert-modal" id="alertModal">
        <div class="alert-content">
            <div class="alert-icon">üîî</div>
            <div class="alert-title" id="alertTitle"></div>
            <div class="alert-description" id="alertDescription"></div>
            <div class="alert-time" id="alertTime"></div>
            <div class="alert-buttons">
                <button class="alert-btn alert-btn-dismiss" onclick="dismissAlert()">Adiar 5 min</button>
                <button class="alert-btn alert-btn-complete" onclick="completeFromAlert()">Concluir</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para Adicionar Hor√°rio -->
    <div class="schedule-modal" id="scheduleModal">
        <div class="schedule-modal-content">
            <div class="schedule-modal-header">‚ûï Adicionar Hor√°rio</div>
            
            <div class="input-group">
                <label>Tipo de Hor√°rio</label>
                <select id="modalScheduleType" onchange="toggleModalScheduleType()">
                    <option value="time">Hor√°rio espec√≠fico</option>
                    <option value="daily">Todos os dias</option>
                    <option value="weekly">Dias da semana</option>
                    <option value="monthly">Dia do m√™s</option>
                </select>
            </div>

            <!-- Hor√°rio Espec√≠fico -->
            <div id="modalTimeSection">
                <div class="input-group">
                    <label>Data e Hora</label>
                    <input type="datetime-local" id="modalTime">
                </div>
            </div>

            <!-- Di√°rio -->
            <div id="modalDailySection" style="display: none;">
                <div class="input-group">
                    <label>Hor√°rio</label>
                    <input type="time" id="modalDailyTime">
                </div>
            </div>

            <!-- Semanal -->
            <div id="modalWeeklySection" style="display: none;">
                <div class="input-group">
                    <label>Dias da Semana</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="0" class="weekday-check"> Domingo
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="1" class="weekday-check"> Segunda
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="2" class="weekday-check"> Ter√ßa
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="3" class="weekday-check"> Quarta
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="4" class="weekday-check"> Quinta
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="5" class="weekday-check"> Sexta
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" value="6" class="weekday-check"> S√°bado
                        </label>
                    </div>
                </div>
                <div class="input-group">
                    <label>Hor√°rio</label>
                    <input type="time" id="modalWeeklyTime">
                </div>
            </div>

            <!-- Mensal -->
            <div id="modalMonthlySection" style="display: none;">
                <div class="input-group">
                    <label>Dia do M√™s</label>
                    <input type="number" id="modalMonthlyDay" min="1" max="31" value="1">
                </div>
                <div class="input-group">
                    <label>Hor√°rio</label>
                    <input type="time" id="modalMonthlyTime">
                </div>
            </div>

            <div class="schedule-modal-buttons">
                <button class="btn-secondary" onclick="closeScheduleModal()">Cancelar</button>
                <button class="btn" onclick="addScheduleToList()">Adicionar</button>
            </div>
        </div>
    </div>

    <audio id="notificationSound" preload="auto">
        <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAASAAAd8wAUFBQUFCIiIiIiIjAwMDAwPj4+Pj4+TExMTExZWVlZWVlnZ2dnZ3V1dXV1dYODg4ODkZGRkZGRn5+fn5+frKysrKy6urq6urrIyMjIyNbW1tbW1uTk5OTk8vLy8vLy//////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAUKAAAAAAAAHfPzV8GIAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkAA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EGQAD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkAA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EGQAD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV" type="audio/mpeg">
    </audio>

    <script>
        let reminders = [];
        let currentTab = 'all';
        let checkInterval;
        let currentAlertReminder = null;
        let currentSchedules = []; // Para armazenar m√∫ltiplos hor√°rios temporariamente

        // Carregar lembretes salvos
        function loadReminders() {
            const saved = JSON.parse(localStorage.getItem('reminders') || '[]');
            reminders = saved.map(r => {
                const reminder = {...r};
                
                // Converter datas nos schedules
                if (reminder.schedules) {
                    reminder.schedules = reminder.schedules.map(s => ({
                        ...s,
                        time: s.time ? (typeof s.time === 'string' && s.time.includes(':') && !s.time.includes('T') ? s.time : new Date(s.time)) : null,
                        recurrenceEnd: s.recurrenceEnd ? new Date(s.recurrenceEnd) : null,
                        intervalEnd: s.intervalEnd ? new Date(s.intervalEnd) : null
                    }));
                }
                
                // Converter datas nas execu√ß√µes
                if (reminder.nextExecutions) {
                    reminder.nextExecutions = reminder.nextExecutions.map(e => ({
                        ...e,
                        time: new Date(e.time)
                    }));
                }
                
                // Compatibilidade retroativa
                if (reminder.time) {
                    reminder.time = new Date(reminder.time);
                }
                if (reminder.recurrenceEnd) {
                    reminder.recurrenceEnd = new Date(reminder.recurrenceEnd);
                }
                
                return reminder;
            });
            displayReminders();
            
            // Processar mensagens pendentes do service worker
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'APP_READY'
                });
            }
        }

        // Salvar lembretes
        function saveReminders() {
            localStorage.setItem('reminders', JSON.stringify(reminders));
            
            // Enviar lembretes atualizados para o service worker
            sendRemindersToServiceWorker();
        }

        // Adicionar lembrete
        function addReminder() {
            const title = document.getElementById('reminderTitle').value.trim();
            const description = document.getElementById('reminderDescription').value.trim();

            if (!title) {
                alert('Por favor, preencha o t√≠tulo do lembrete');
                return;
            }

            if (currentSchedules.length === 0) {
                alert('Por favor, adicione pelo menos um hor√°rio');
                return;
            }

            // Criar um √∫nico lembrete com m√∫ltiplos hor√°rios
            const reminder = {
                id: Date.now(),
                title,
                description,
                schedules: currentSchedules.map(s => ({...s})), // Copiar array de hor√°rios
                nextExecutions: [], // Ser√° preenchido abaixo
                completed: false
            };

            // Calcular pr√≥ximas execu√ß√µes para cada hor√°rio
            reminder.nextExecutions = currentSchedules.map((schedule, index) => ({
                scheduleIndex: index,
                time: calculateNextTimeForSchedule(schedule),
                notified: false
            }));

            reminders.push(reminder);
            saveReminders();
            displayReminders();

            // Limpar formul√°rio
            document.getElementById('reminderTitle').value = '';
            document.getElementById('reminderDescription').value = '';
            document.getElementById('reminderTime').value = '';
            document.getElementById('recurrenceType').value = 'none';
            document.getElementById('recurrenceEnd').value = '';
            document.getElementById('scheduleType').value = 'specific';
            document.getElementById('intervalValue').value = '30';
            document.getElementById('intervalUnit').value = 'minutes';
            document.getElementById('intervalStart').value = '';
            document.getElementById('intervalEnd').value = '';
            currentSchedules = [];
            toggleScheduleType();
            toggleRecurrenceOptions();
            renderMainSchedulesList();

            showNotification('Lembrete criado com sucesso!');
        }

        // Calcular pr√≥ximo hor√°rio para um agendamento espec√≠fico
        function calculateNextTimeForSchedule(schedule) {
            if (schedule.scheduleType === 'specific') {
                return schedule.time;
            } else if (schedule.scheduleType === 'interval') {
                return schedule.time;
            } else if (schedule.scheduleType === 'complex') {
                return calculateNextComplexTime(schedule);
            }
            return new Date();
        }

        // Calcular pr√≥ximo hor√°rio para agendamento complexo
        function calculateNextComplexTime(schedule) {
            const now = new Date();
            
            if (schedule.type === 'time') {
                return schedule.time;
            } else if (schedule.type === 'daily') {
                const [hours, minutes] = schedule.time.split(':');
                const next = new Date();
                next.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                
                if (next <= now) {
                    next.setDate(next.getDate() + 1);
                }
                return next;
            } else if (schedule.type === 'weekly') {
                const [hours, minutes] = schedule.time.split(':');
                const currentDay = now.getDay();
                
                // Encontrar o pr√≥ximo dia da semana
                let daysUntilNext = 7;
                for (let day of schedule.weekdays.sort()) {
                    const diff = day - currentDay;
                    if (diff > 0 || (diff === 0 && now.getHours() * 60 + now.getMinutes() < parseInt(hours) * 60 + parseInt(minutes))) {
                        daysUntilNext = diff > 0 ? diff : 0;
                        break;
                    }
                }
                
                if (daysUntilNext === 7) {
                    daysUntilNext = 7 - currentDay + schedule.weekdays[0];
                }
                
                const next = new Date(now);
                next.setDate(next.getDate() + daysUntilNext);
                next.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                return next;
            } else if (schedule.type === 'monthly') {
                const [hours, minutes] = schedule.time.split(':');
                const next = new Date();
                next.setDate(schedule.day);
                next.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                
                if (next <= now) {
                    next.setMonth(next.getMonth() + 1);
                }
                return next;
            }
            
            return new Date();
        }

        // Exibir lembretes
        function displayReminders() {
            const container = document.getElementById('remindersList');
            let filtered = [...reminders].filter(r => !r.completed);

            // Filtrar por aba
            const now = new Date();
            if (currentTab === 'upcoming') {
                filtered = filtered.filter(r => r.time > now);
            } else if (currentTab === 'overdue') {
                filtered = filtered.filter(r => r.time <= now);
            }

            // Ordenar por data
            filtered.sort((a, b) => a.time - b.time);

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state">Nenhum lembrete encontrado</div>';
                return;
            }

// Compatibilidade retroativa - adicionar scheduleType se n√£o existir
            filtered.forEach(r => {
                if (!r.scheduleType) {
                    r.scheduleType = 'specific';
                    if (!r.recurrenceType) r.recurrenceType = 'none';
                }
            });

            container.innerHTML = filtered.map(reminder => {
                // Compatibilidade retroativa
                if (!reminder.schedules) {
                    reminder.schedules = [{
                        scheduleType: reminder.scheduleType || 'specific',
                        time: reminder.time,
                        recurrenceType: reminder.recurrenceType || 'none',
                        recurrenceEnd: reminder.recurrenceEnd
                    }];
                    reminder.nextExecutions = [{
                        scheduleIndex: 0,
                        time: reminder.time,
                        notified: reminder.notified || false
                    }];
                }

                // Encontrar pr√≥xima execu√ß√£o
                const nextExec = reminder.nextExecutions
                    .filter(e => e.time)
                    .sort((a, b) => new Date(a.time) - new Date(b.time))[0];
                
                if (!nextExec) return '';

                const nextTime = new Date(nextExec.time);
                const now = new Date();
                const isOverdue = nextTime <= now;
                const timeStr = formatDateTime(nextTime);
                
                return `
                    <div class="reminder-item ${isOverdue ? 'overdue' : ''}">
                        <div class="reminder-content">
                            <div class="reminder-title">
                                ${reminder.title}
                                ${reminder.schedules.length > 1 ? 
                                    `<span class="badge badge-recurring">üìÖ ${reminder.schedules.length} hor√°rios</span>` 
                                    : getScheduleBadge(reminder.schedules[0])}
                            </div>
                            <div class="reminder-time">${isOverdue ? '‚ö†Ô∏è ' : 'üïê '}${timeStr}</div>
                            ${reminder.description ? `<div class="reminder-description">${reminder.description}</div>` : ''}
                            ${reminder.schedules.length > 1 ? `
                                <div class="reminder-description" style="margin-top: 8px;">
                                    <strong>Hor√°rios configurados:</strong><br>
                                    ${reminder.schedules.map((s, i) => `‚Ä¢ ${s.label || 'Hor√°rio ' + (i+1)}`).join('<br>')}
                                </div>
                            ` : ''}
                        </div>
                        <div class="reminder-actions">
                            <button class="btn-small btn-complete" onclick="completeReminder(${reminder.id})">‚úì</button>
                            <button class="btn-small btn-delete" onclick="deleteReminder(${reminder.id})">‚úï</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Obter label do tipo principal de agendamento
        function getScheduleMainTypeLabel(scheduleType) {
            const labels = {
                'specific': 'Hor√°rio espec√≠fico',
                'interval': 'Intervalo',
                'complex': 'Complexo'
            };
            return labels[scheduleType] || scheduleType;
        }

        // Remover hor√°rio da lista
        function removeSchedule(index) {
            currentSchedules.splice(index, 1);
            renderMainSchedulesList();
        }

        // Obter label do tipo de hor√°rio
        function getScheduleTypeLabel(type) {
            const labels = {
                'time': 'Hor√°rio espec√≠fico',
                'daily': 'Di√°rio',
                'weekly': 'Semanal',
                'monthly': 'Mensal'
            };
            return labels[type] || type;
        }

        // Trocar aba
        function showTab(tab) {
            currentTab = tab;
            
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            displayReminders();
        }

        // Mostrar notifica√ß√£o
        function showNotification(message) {
            const badge = document.getElementById('notificationBadge');
            badge.textContent = message;
            badge.style.display = 'block';
            
            setTimeout(() => {
                badge.style.display = 'none';
            }, 3000);
        }
        
        // Completar lembrete
        function completeReminder(id) {
            const reminder = reminders.find(r => r.id === id);
            if (!reminder) return;
            
            // Fechar notifica√ß√£o da barra do Android
            closeSystemNotification(id);
            
            // Fechar modal se estiver aberto
            if (currentAlertReminder && currentAlertReminder.id === id) {
                document.getElementById('alertModal').classList.remove('show');
                currentAlertReminder = null;
            }

            // Compatibilidade retroativa - lembretes antigos
            if (!reminder.schedules || !reminder.nextExecutions) {
                reminder.completed = true;
                saveReminders();
                displayReminders();
                showNotification('Lembrete conclu√≠do!');
                return;
            }

            // Novo sistema: Recalcular todas as pr√≥ximas execu√ß√µes
            let hasMoreExecutions = false;
            
            reminder.nextExecutions = reminder.schedules.map((schedule, index) => {
                const currentExec = reminder.nextExecutions.find(e => e.scheduleIndex === index);
                
                // Se j√° passou, calcular pr√≥xima
                if (currentExec && new Date(currentExec.time) <= new Date()) {
                    const nextTime = calculateNextRecurrenceForSchedule(schedule, new Date(currentExec.time));
                    
                    if (nextTime) {
                        hasMoreExecutions = true;
                        return {
                            scheduleIndex: index,
                            time: nextTime,
                            notified: false
                        };
                    }
                } else if (currentExec) {
                    // Ainda n√£o passou, manter
                    hasMoreExecutions = true;
                    return currentExec;
                }
                
                return null;
            }).filter(e => e !== null);

            if (hasMoreExecutions) {
                saveReminders();
                displayReminders();
                showNotification('Pr√≥xima ocorr√™ncia agendada!');
            } else {
                reminder.completed = true;
                saveReminders();
                displayReminders();
                showNotification('Lembrete conclu√≠do!');
            }
        }

        // Calcular pr√≥xima recorr√™ncia para um schedule
        function calculateNextRecurrenceForSchedule(schedule, currentTime) {
            if (schedule.scheduleType === 'specific') {
                if (schedule.recurrenceType === 'none') return null;
                
                const nextTime = getNextRecurrence(currentTime, schedule.recurrenceType);
                if (schedule.recurrenceEnd && nextTime > schedule.recurrenceEnd) {
                    return null;
                }
                return nextTime;
                
            } else if (schedule.scheduleType === 'interval') {
                const nextTime = new Date(currentTime);
                
                if (schedule.intervalUnit === 'minutes') {
                    nextTime.setMinutes(nextTime.getMinutes() + schedule.intervalValue);
                } else if (schedule.intervalUnit === 'hours') {
                    nextTime.setHours(nextTime.getHours() + schedule.intervalValue);
                } else if (schedule.intervalUnit === 'days') {
                    nextTime.setDate(nextTime.getDate() + schedule.intervalValue);
                }
                
                if (schedule.intervalEnd && nextTime > new Date(schedule.intervalEnd)) {
                    return null;
                }
                return nextTime;
                
            } else if (schedule.scheduleType === 'complex') {
                return calculateNextComplexTime(schedule);
            }
            
            return null;
        }

        // Deletar lembrete
        function deleteReminder(id) {
            if (!confirm('Deseja realmente excluir este lembrete?')) return;
            
            reminders = reminders.filter(r => r.id !== id);
            saveReminders();
            displayReminders();
            showNotification('Lembrete exclu√≠do!');
        }

        // Calcular pr√≥xima recorr√™ncia
        function getNextRecurrence(currentDate, type) {
            const next = new Date(currentDate);
            
            switch(type) {
                case 'daily':
                    next.setDate(next.getDate() + 1);
                    break;
                case 'weekly':
                    next.setDate(next.getDate() + 7);
                    break;
                case 'monthly':
                    next.setMonth(next.getMonth() + 1);
                    break;
            }
            
            return next;
        }

        // Formatar data e hora
        function formatDateTime(date) {
            const now = new Date();
            const diff = date - now;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            const dateStr = date.toLocaleDateString('pt-BR');
            const timeStr = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
            
            if (days === 0) return `Hoje √†s ${timeStr}`;
            if (days === 1) return `Amanh√£ √†s ${timeStr}`;
            if (days === -1) return `Ontem √†s ${timeStr}`;
            
            return `${dateStr} √†s ${timeStr}`;
        }

        // Label de recorr√™ncia
        function getRecurrenceLabel(type) {
            const labels = {
                'daily': 'Di√°rio',
                'weekly': 'Semanal',
                'monthly': 'Mensal'
            };
            return labels[type] || '';
        }

        // Obter badge de agendamento
        function getScheduleBadge(reminder) {
            if (reminder.scheduleType === 'specific' && reminder.recurrenceType !== 'none') {
                return `<span class="badge badge-recurring">üîÑ ${getRecurrenceLabel(reminder.recurrenceType)}</span>`;
            } else if (reminder.scheduleType === 'interval') {
                const unitLabels = { 'minutes': 'min', 'hours': 'h', 'days': 'd' };
                return `<span class="badge badge-recurring">‚è±Ô∏è ${reminder.intervalValue}${unitLabels[reminder.intervalUnit]}</span>`;
            } else if (reminder.scheduleType === 'complex' && reminder.complexSchedule) {
                return `<span class="badge badge-recurring">üìÖ ${getScheduleTypeLabel(reminder.complexSchedule.type)}</span>`;
            }
            return '';
        }

        // Mostrar/ocultar op√ß√µes de recorr√™ncia
        function toggleRecurrenceOptions() {
            const type = document.getElementById('recurrenceType').value;
            const options = document.getElementById('recurrenceOptions');
            
            if (type !== 'none') {
                options.classList.add('show');
            } else {
                options.classList.remove('show');
            }
        }

        // Alternar tipo de agendamento
        function toggleScheduleType() {
            const type = document.getElementById('scheduleType').value;
            
            // Ocultar todas as se√ß√µes
            document.getElementById('specificTimeSection').style.display = 'none';
            document.getElementById('intervalSection').style.display = 'none';
            
            // Mostrar se√ß√£o apropriada
            if (type === 'specific') {
                document.getElementById('specificTimeSection').style.display = 'block';
            } else if (type === 'interval') {
                document.getElementById('intervalSection').style.display = 'block';
                setDefaultIntervalTime();
            } else if (type === 'complex') {
                // Modo complexo n√£o tem campos adicionais, apenas bot√£o de adicionar hor√°rio
            }
        }

        // Definir hora padr√£o para intervalo
        function setDefaultIntervalTime() {
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            document.getElementById('intervalStart').value = now.toISOString().slice(0, 16);
        }

        // Alternar tipo de hor√°rio no modal
        function toggleModalScheduleType() {
            const type = document.getElementById('modalScheduleType').value;
            
            // Ocultar todas as se√ß√µes
            document.getElementById('modalTimeSection').style.display = 'none';
            document.getElementById('modalDailySection').style.display = 'none';
            document.getElementById('modalWeeklySection').style.display = 'none';
            document.getElementById('modalMonthlySection').style.display = 'none';
            
            // Mostrar se√ß√£o apropriada
            if (type === 'time') {
                document.getElementById('modalTimeSection').style.display = 'block';
            } else if (type === 'daily') {
                document.getElementById('modalDailySection').style.display = 'block';
            } else if (type === 'weekly') {
                document.getElementById('modalWeeklySection').style.display = 'block';
            } else if (type === 'monthly') {
                document.getElementById('modalMonthlySection').style.display = 'block';
            }
        }

        // Abrir modal de hor√°rio
        function openScheduleModal() {
            document.getElementById('scheduleModal').classList.add('show');
            toggleModalScheduleType();
        }

        // Fechar modal de hor√°rio
        function closeScheduleModal() {
            document.getElementById('scheduleModal').classList.remove('show');
            
            // Limpar campos
            document.getElementById('modalTime').value = '';
            document.getElementById('modalDailyTime').value = '';
            document.getElementById('modalWeeklyTime').value = '';
            document.getElementById('modalMonthlyTime').value = '';
            document.getElementById('modalMonthlyDay').value = '1';
            document.querySelectorAll('.weekday-check').forEach(cb => cb.checked = false);
        }

        // Adicionar hor√°rio ao lembrete (do formul√°rio principal)
        function addScheduleToReminder() {
            const scheduleType = document.getElementById('scheduleType').value;
            let schedule = { scheduleType };
            
            if (scheduleType === 'specific') {
                const time = document.getElementById('reminderTime').value;
                const recurrenceType = document.getElementById('recurrenceType').value;
                const recurrenceEnd = document.getElementById('recurrenceEnd').value;
                
                if (!time) {
                    alert('Por favor, selecione uma data e hora');
                    return;
                }
                
                schedule.time = new Date(time);
                schedule.recurrenceType = recurrenceType;
                schedule.recurrenceEnd = recurrenceEnd ? new Date(recurrenceEnd) : null;
                
                if (recurrenceType !== 'none') {
                    schedule.label = `${formatDateTime(schedule.time)} - ${getRecurrenceLabel(recurrenceType)}`;
                } else {
                    schedule.label = formatDateTime(schedule.time);
                }
                
            } else if (scheduleType === 'interval') {
                const intervalValue = parseInt(document.getElementById('intervalValue').value);
                const intervalUnit = document.getElementById('intervalUnit').value;
                const intervalStart = document.getElementById('intervalStart').value;
                const intervalEnd = document.getElementById('intervalEnd').value;
                
                if (!intervalStart || intervalValue < 1) {
                    alert('Por favor, configure o intervalo corretamente');
                    return;
                }
                
                schedule.intervalValue = intervalValue;
                schedule.intervalUnit = intervalUnit;
                schedule.time = new Date(intervalStart);
                schedule.intervalEnd = intervalEnd ? new Date(intervalEnd) : null;
                
                const unitLabels = { 'minutes': 'minutos', 'hours': 'horas', 'days': 'dias' };
                schedule.label = `A cada ${intervalValue} ${unitLabels[intervalUnit]} desde ${formatDateTime(schedule.time)}`;
                
            } else if (scheduleType === 'complex') {
                alert('Para modo complexo, clique em "Adicionar Hor√°rio" e configure no modal');
                openScheduleModal();
                return;
            }
            
            currentSchedules.push(schedule);
            renderMainSchedulesList();
            showNotification('Hor√°rio adicionado!');
            
            // Limpar campos
            document.getElementById('reminderTime').value = '';
            document.getElementById('recurrenceType').value = 'none';
            document.getElementById('recurrenceEnd').value = '';
            document.getElementById('intervalValue').value = '30';
            document.getElementById('intervalStart').value = '';
            document.getElementById('intervalEnd').value = '';
            toggleRecurrenceOptions();
        }

        // Adicionar hor√°rio √† lista (do modal)
        function addScheduleToList() {
            const type = document.getElementById('modalScheduleType').value;
            let schedule = { scheduleType: 'complex', type };
            
            if (type === 'time') {
                const time = document.getElementById('modalTime').value;
                if (!time) {
                    alert('Por favor, selecione uma data e hora');
                    return;
                }
                schedule.time = new Date(time);
                schedule.label = formatDateTime(schedule.time);
            } else if (type === 'daily') {
                const time = document.getElementById('modalDailyTime').value;
                if (!time) {
                    alert('Por favor, selecione um hor√°rio');
                    return;
                }
                schedule.time = time;
                schedule.label = `Todos os dias √†s ${time}`;
            } else if (type === 'weekly') {
                const time = document.getElementById('modalWeeklyTime').value;
                const days = Array.from(document.querySelectorAll('.weekday-check:checked')).map(cb => parseInt(cb.value));
                
                if (!time || days.length === 0) {
                    alert('Por favor, selecione os dias e o hor√°rio');
                    return;
                }
                
                schedule.time = time;
                schedule.weekdays = days;
                const dayNames = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'S√°b'];
                schedule.label = `${days.map(d => dayNames[d]).join(', ')} √†s ${time}`;
            } else if (type === 'monthly') {
                const time = document.getElementById('modalMonthlyTime').value;
                const day = document.getElementById('modalMonthlyDay').value;
                
                if (!time || !day) {
                    alert('Por favor, selecione o dia e o hor√°rio');
                    return;
                }
                
                schedule.time = time;
                schedule.day = parseInt(day);
                schedule.label = `Dia ${day} de cada m√™s √†s ${time}`;
            }
            
            currentSchedules.push(schedule);
            renderMainSchedulesList();
            closeScheduleModal();
        }

        // Renderizar lista principal de hor√°rios (no formul√°rio)
        function renderMainSchedulesList() {
            const container = document.getElementById('mainSchedulesList');
            
            if (currentSchedules.length === 0) {
                container.innerHTML = '<div class="empty-schedules">Nenhum hor√°rio configurado. Clique em "Adicionar Hor√°rio"</div>';
                return;
            }
            
            container.innerHTML = currentSchedules.map((schedule, index) => `
                <div class="schedule-item">
                    <div class="schedule-item-info">
                        <div class="schedule-item-time">${schedule.label}</div>
                        <div class="schedule-item-type">${getScheduleMainTypeLabel(schedule.scheduleType)}</div>
                    </div>
                    <button class="btn-remove-schedule" onclick="removeSchedule(${index})">‚úï</button>
                </div>
            `).join('');
        }

        // Verificar lembretes vencidos
        function checkReminders() {
            const now = new Date();
            
            reminders.forEach(reminder => {
                if (reminder.completed) return;
                
                // Compatibilidade retroativa
                if (!reminder.nextExecutions && reminder.time) {
                    // Lembrete antigo - converter para novo formato
                    if (!reminder.notified && new Date(reminder.time) <= now) {
                        reminder.notified = true;
                        triggerAlert(reminder);
                    }
                    return;
                }
                
                // Novo sistema com m√∫ltiplos hor√°rios
                if (reminder.nextExecutions) {
                    reminder.nextExecutions.forEach(execution => {
                        const execTime = new Date(execution.time);
                        if (!execution.notified && execTime <= now) {
                            execution.notified = true;
                            triggerAlert(reminder);
                        }
                    });
                }
            });
            
            saveReminders();
            displayReminders();
        }

        // Disparar alerta com som e vibra√ß√£o
        function triggerAlert(reminder) {
            console.log('üîî Disparando alerta para:', reminder.title);
            currentAlertReminder = reminder;
            
            // Tocar som
            const sound = document.getElementById('notificationSound');
            sound.play().catch(e => console.log('Erro ao tocar som:', e));
            
            // Vibrar (se dispon√≠vel)
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            // SEMPRE mostrar o modal se o app estiver aberto
            showAlertModal(reminder);
            
            // Enviar para Service Worker mostrar notifica√ß√£o NATIVA
            if (swRegistration && swRegistration.active) {
                swRegistration.active.postMessage({
                    type: 'SHOW_NOTIFICATION',
                    reminder: {
                        id: reminder.id,
                        title: reminder.title,
                        description: reminder.description
                    }
                });
            }
        }

        // Mostrar modal de alerta
        function showAlertModal(reminder) {
            // Encontrar o tempo correto para exibir
            let displayTime = reminder.time;
            if (reminder.nextExecutions && reminder.nextExecutions.length > 0) {
                const nextExec = reminder.nextExecutions
                    .filter(e => e.time)
                    .sort((a, b) => new Date(a.time) - new Date(b.time))[0];
                if (nextExec) {
                    displayTime = nextExec.time;
                }
            }
            
            document.getElementById('alertTitle').textContent = reminder.title;
            document.getElementById('alertDescription').textContent = reminder.description || 'Seu lembrete chegou!';
            document.getElementById('alertTime').textContent = formatDateTime(new Date(displayTime));
            document.getElementById('alertModal').classList.add('show');
            
            // Tocar som novamente a cada 10 segundos at√© fechar
            const soundInterval = setInterval(() => {
                if (!document.getElementById('alertModal').classList.contains('show')) {
                    clearInterval(soundInterval);
                    return;
                }
                const sound = document.getElementById('notificationSound');
                sound.play().catch(e => console.log('Erro ao tocar som:', e));
            }, 10000);
        }

        // Dispensar alerta (adiar 5 minutos)
        function dismissAlert() {
            if (currentAlertReminder) {
                // Fechar notifica√ß√£o da barra do Android
                closeSystemNotification(currentAlertReminder.id);
                
                snoozeReminderById(currentAlertReminder.id, 5, true);
            }
            document.getElementById('alertModal').classList.remove('show');
            currentAlertReminder = null;
        }
        
        // Fechar notifica√ß√£o do sistema (barra de notifica√ß√µes do Android)
        function closeSystemNotification(reminderId) {
            if (swRegistration && swRegistration.active) {
                swRegistration.active.postMessage({
                    type: 'CLOSE_NOTIFICATION',
                    reminderId: reminderId
                });
                console.log('üö´ Solicitado fechamento de notifica√ß√£o:', reminderId);
            }
        }
        
        // Concluir lembrete a partir da notifica√ß√£o do sistema
        function completeReminderFromNotification(reminderId, closeModal) {
            console.log('‚úÖ completeReminderFromNotification chamado:', reminderId, 'closeModal:', closeModal);
            
            const reminder = reminders.find(r => r.id === reminderId);
            if (!reminder) {
                console.log('‚ùå Lembrete n√£o encontrado:', reminderId);
                return;
            }
            
            // Fechar modal se solicitado
            if (closeModal) {
                console.log('üö™ Fechando modal (closeModal=true)');
                const modal = document.getElementById('alertModal');
                if (modal) {
                    modal.classList.remove('show');
                }
                currentAlertReminder = null;
            }
            
            // Concluir o lembrete normalmente
            completeReminder(reminderId);
        }
        
        // Adiar lembrete por ID (chamado pelo service worker)
        function snoozeReminderById(reminderId, minutes, closeModal) {
            console.log('‚è∞ snoozeReminderById chamado:', reminderId, minutes, 'closeModal:', closeModal);
            
            const reminder = reminders.find(r => r.id === reminderId);
            if (!reminder) {
                console.log('‚ùå Lembrete n√£o encontrado:', reminderId);
                return;
            }
            
            // Fechar notifica√ß√£o da barra do Android
            closeSystemNotification(reminderId);
            
            // Compatibilidade retroativa
            if (!reminder.nextExecutions && reminder.time) {
                const newTime = new Date(reminder.time);
                newTime.setMinutes(newTime.getMinutes() + minutes);
                reminder.time = newTime;
                reminder.notified = false;
            } else if (reminder.nextExecutions) {
                // Novo sistema: adiar todas as execu√ß√µes pendentes
                reminder.nextExecutions = reminder.nextExecutions.map(exec => {
                    if (new Date(exec.time) <= new Date()) {
                        const newTime = new Date(exec.time);
                        newTime.setMinutes(newTime.getMinutes() + minutes);
                        return {
                            ...exec,
                            time: newTime,
                            notified: false
                        };
                    }
                    return exec;
                });
            }
            
            saveReminders();
            displayReminders();
            showNotification(`Lembrete adiado por ${minutes} minutos`);
            
            // Fechar modal se solicitado (closeModal === true)
            if (closeModal === true) {
                console.log('üö™ Fechando modal via closeModal=true');
                const modal = document.getElementById('alertModal');
                if (modal) {
                    modal.classList.remove('show');
                }
                currentAlertReminder = null;
            } else {
                console.log('‚ÑπÔ∏è Modal mantido aberto (closeModal n√£o √© true, √©:', closeModal, ')');
            }
        }

        // Concluir a partir do alerta
        function completeFromAlert() {
            if (currentAlertReminder) {
                // Fechar notifica√ß√£o da barra do Android
                closeSystemNotification(currentAlertReminder.id);
                
                completeReminder(currentAlertReminder.id);
            }
            document.getElementById('alertModal').classList.remove('show');
            currentAlertReminder = null;
        }

// Fun√ß√£o de debug
        function debugReminders() {
            console.log('üêõ ===== DEBUG DE LEMBRETES =====');
            console.log('üìã Lembretes no App:', reminders);
            console.log('üíæ Lembretes no localStorage:', JSON.parse(localStorage.getItem('reminders') || '[]'));
            
            // Mostrar pr√≥ximos hor√°rios
            reminders.forEach(r => {
                if (!r.completed) {
                    if (r.nextExecutions && r.nextExecutions.length > 0) {
                        const nextExec = r.nextExecutions[0];
                        console.log(`üìÖ APP [${r.title}] Pr√≥ximo: ${new Date(nextExec.time).toLocaleString()} | Notificado: ${nextExec.notified}`);
                    } else if (r.time) {
                        console.log(`üìÖ APP [${r.title}] Pr√≥ximo: ${new Date(r.time).toLocaleString()} | Notificado: ${r.notified}`);
                    }
                }
            });
            
            if (swRegistration && swRegistration.active) {
                // Pedir ao SW para mostrar seus lembretes
                const channel = new MessageChannel();
                channel.port1.onmessage = (event) => {
                    if (event.data.type === 'DEBUG_RESPONSE') {
                        console.log('üîß Lembretes no Service Worker:', event.data.reminders);
                        
                        let msg = 'Debug completo! Veja o console (F12) para detalhes.\n\n';
                        msg += 'App: ' + reminders.length + ' lembretes\n';
                        msg += 'SW: ' + event.data.reminders.length + ' lembretes\n\n';
                        
                        // Comparar hor√°rios
                        const appReminder = reminders[0];
                        const swReminder = event.data.reminders[0];
                        
                        if (appReminder && swReminder) {
                            const appTime = appReminder.nextExecutions ? 
                                new Date(appReminder.nextExecutions[0].time) : 
                                new Date(appReminder.time);
                            const swTime = swReminder.nextExecutions ? 
                                new Date(swReminder.nextExecutions[0].time) : 
                                new Date(swReminder.time);
                            
                            msg += 'Pr√≥ximo hor√°rio:\n';
                            msg += 'App: ' + appTime.toLocaleTimeString() + '\n';
                            msg += 'SW: ' + swTime.toLocaleTimeString();
                            
                            if (appTime.getTime() !== swTime.getTime()) {
                                msg += '\n\n‚ö†Ô∏è HOR√ÅRIOS DIFERENTES!';
                            }
                        }
                        
                        alert(msg);
                    }
                };
                
                swRegistration.active.postMessage(
                    { type: 'DEBUG_REQUEST' },
                    [channel.port2]
                );
            } else {
                alert('Service Worker n√£o est√° ativo!');
            }
        }

// FUN√á√ÉO DE TESTE - DESCOMENTE PARA ATIVAR
        /*
        function testarNotificacao() {
            console.log('üß™ Testando notifica√ß√£o...');
            
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    const testReminder = {
                        id: Date.now(),
                        title: 'Teste de Notifica√ß√£o',
                        description: 'Se voc√™ est√° vendo isso NA √ÅREA DE NOTIFICA√á√ïES, est√° funcionando! ‚úÖ',
                        time: new Date()
                    };
                    
                    // Enviar diretamente para o Service Worker
                    if (swRegistration && swRegistration.active) {
                        swRegistration.active.postMessage({
                            type: 'SHOW_NOTIFICATION',
                            reminder: testReminder
                        });
                        alert('‚úÖ Notifica√ß√£o enviada! Verifique a √°rea de notifica√ß√µes do seu Android.');
                    } else {
                        alert('‚ùå Service Worker n√£o est√° ativo. Recarregue a p√°gina.');
                    }
                } else if (Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            alert('‚úÖ Permiss√£o concedida! Clique em "Testar Notifica√ß√£o" novamente.');
                        } else {
                            alert('‚ùå Voc√™ precisa permitir notifica√ß√µes nas configura√ß√µes do navegador.');
                        }
                    });
                } else {
                    alert('‚ùå Notifica√ß√µes bloqueadas. V√° nas configura√ß√µes do navegador (‚ãÆ > Configura√ß√µes do site > Notifica√ß√µes) e permita.');
                }
            } else {
                alert('‚ùå Seu navegador n√£o suporta notifica√ß√µes.');
            }
        }
        */

        // Solicitar permiss√£o de notifica√ß√£o
        function requestNotificationPermission() {
            if ('Notification' in window) {
                if (Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        console.log('Permiss√£o de notifica√ß√£o:', permission);
                        if (permission === 'granted') {
                            showNotification('‚úÖ Notifica√ß√µes ativadas!');
                        }
                    });
                } else {
                    console.log('Status atual de notifica√ß√£o:', Notification.permission);
                }
            }
        }

        // Service Worker e PWA
        let deferredPrompt;
        let swRegistration;
        
        // Listener global para mensagens do service worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', function(event) {
                console.log('üì® [GLOBAL LISTENER] Mensagem do SW:', event.data);
                
                if (!event.data || !event.data.type) {
                    console.log('‚ö†Ô∏è Mensagem sem tipo');
                    return;
                }
                
                // Processar mensagens do SW
                if (event.data.type === 'SYNC_REMINDERS_TO_LOCALSTORAGE') {
                    console.log('üîÑ [GLOBAL] Sincronizando lembretes do SW para localStorage');
                    
                    // Receber lembretes atualizados do SW e salvar no localStorage
                    reminders = event.data.reminders.map(r => {
                        const reminder = {...r};
                        
                        // Converter datas nos schedules
                        if (reminder.schedules) {
                            reminder.schedules = reminder.schedules.map(s => ({
                                ...s,
                                time: s.time ? (typeof s.time === 'string' && s.time.includes(':') && !s.time.includes('T') ? s.time : new Date(s.time)) : null,
                                recurrenceEnd: s.recurrenceEnd ? new Date(s.recurrenceEnd) : null,
                                intervalEnd: s.intervalEnd ? new Date(s.intervalEnd) : null
                            }));
                        }
                        
                        // Converter datas nas execu√ß√µes
                        if (reminder.nextExecutions) {
                            reminder.nextExecutions = reminder.nextExecutions.map(e => ({
                                ...e,
                                time: new Date(e.time)
                            }));
                        }
                        
                        return reminder;
                    });
                    
                    // Salvar no localStorage
                    localStorage.setItem('reminders', JSON.stringify(reminders));
                    
                    // Atualizar UI
                    displayReminders();
                    
                    console.log('‚úÖ [GLOBAL] Lembretes sincronizados com sucesso');
                    
                } else if (event.data.type === 'SNOOZE_REMINDER') {
                    console.log('‚è∞ [GLOBAL] SW processou adiar:', event.data.reminderId);
                    
                    // SW j√° sincronizou via SYNC_REMINDERS_TO_LOCALSTORAGE
                    // Apenas fechar modal se solicitado
                    if (event.data.closeModal) {
                        const modal = document.getElementById('alertModal');
                        if (modal) {
                            modal.classList.remove('show');
                        }
                        currentAlertReminder = null;
                    }
                    
                } else if (event.data.type === 'COMPLETE_REMINDER') {
                    console.log('‚úÖ [GLOBAL] SW processou conclus√£o:', event.data.reminderId);
                    
                    // SW j√° sincronizou via SYNC_REMINDERS_TO_LOCALSTORAGE
                    // Apenas fechar modal se solicitado
                    if (event.data.closeModal) {
                        const modal = document.getElementById('alertModal');
                        if (modal) {
                            modal.classList.remove('show');
                        }
                        currentAlertReminder = null;
                    }
                }
            });
        }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./service-worker.js', { updateViaCache: 'none' })
                .then(registration => {
                    swRegistration = registration;
                    console.log('‚úÖ Service Worker registrado');
                    
                    // For√ßar atualiza√ß√£o do SW a cada 5 minutos
                    setInterval(() => {
                        registration.update();
                        console.log('üîÑ SW atualizado');
                    }, 5 * 60 * 1000);
                    
                    // Atualiza√ß√£o imediata
                    registration.update();
                    
                    // Solicitar permiss√£o para notifica√ß√µes
                    if ('Notification' in window && Notification.permission === 'default') {
                        Notification.requestPermission().then(permission => {
                            console.log('üîî Permiss√£o de notifica√ß√£o:', permission);
                        });
                    }
                    
                    // Enviar lembretes para o SW imediatamente
                    setTimeout(() => {
                        sendRemindersToServiceWorker();
                    }, 1000);
                    
                    // Re-enviar lembretes periodicamente (backup)
                    setInterval(() => {
                        sendRemindersToServiceWorker();
                    }, 2 * 60 * 1000); // A cada 2 minutos
                })
                .catch(error => console.log('‚ùå Erro ao registrar Service Worker:', error));

            // Receber mensagens do service worker (listener secund√°rio)
            navigator.serviceWorker.addEventListener('message', event => {
                console.log('üì® [LISTENER 2] Mensagem do SW:', event.data.type);
                
                if (event.data && event.data.type === 'REQUEST_REMINDERS') {
                    sendRemindersToServiceWorker();
                } else if (event.data && event.data.type === 'CHECK_NOW') {
                    checkReminders();
                } else if (event.data && event.data.type === 'REMINDER_TRIGGERED') {
                    checkReminders();
                }
            });
        }

        // Detectar possibilidade de instala√ß√£o
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installButton').style.display = 'block';
        });

        // Bot√£o de instala√ß√£o
        document.getElementById('installButton').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`Usu√°rio ${outcome === 'accepted' ? 'aceitou' : 'recusou'} a instala√ß√£o`);
                deferredPrompt = null;
                document.getElementById('installButton').style.display = 'none';
            }
        });

        // Enviar lembretes para o service worker
        function sendRemindersToServiceWorker() {
            if (swRegistration && swRegistration.active) {
                const activeReminders = reminders.filter(r => !r.completed);
                console.log('üì§ Enviando', activeReminders.length, 'lembretes para SW');
                swRegistration.active.postMessage({
                    type: 'UPDATE_REMINDERS',
                    reminders: activeReminders
                });
            }
        }
        
        // Reabrir modal quando o app ganhar foco (se houver lembrete pendente)
        window.addEventListener('focus', function() {
            if (currentAlertReminder) {
                showAlertModal(currentAlertReminder);
            }
        });
        
        // Reabrir modal quando o app ganhar foco (se houver lembrete pendente)
        window.addEventListener('focus', function() {
            console.log('üëÅÔ∏è App ganhou foco');
            if (currentAlertReminder) {
                console.log('üîî Reabrindo modal para lembrete:', currentAlertReminder.title);
                showAlertModal(currentAlertReminder);
            }
        });
        
        // Detectar quando a p√°gina fica vis√≠vel
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && currentAlertReminder) {
                console.log('üëÅÔ∏è P√°gina ficou vis√≠vel, reabrindo modal');
                showAlertModal(currentAlertReminder);
            }
        });

// Sistema de Keep-Alive para manter SW ativo
        function startKeepAlive() {
            // Ping ao SW a cada 10 segundos (mais frequente)
            setInterval(() => {
                if (swRegistration && swRegistration.active) {
                    const channel = new MessageChannel();
                    channel.port1.onmessage = (event) => {
                        if (event.data.type === 'ALIVE') {
                            console.log('üíö SW est√° vivo');
                        }
                    };
                    
                    swRegistration.active.postMessage(
                        { type: 'KEEP_ALIVE' },
                        [channel.port2]
                    );
                }
            }, 10000);
            
            // Enviar lembretes a cada 15 segundos (mais frequente)
            setInterval(() => {
                sendRemindersToServiceWorker();
            }, 15000);
            
            // Heartbeat visual no console para debug
            setInterval(() => {
                console.log('üíì Heartbeat do app:', new Date().toLocaleTimeString());
            }, 60000); // A cada 1 minuto
            
            // For√ßar verifica√ß√£o de lembretes mesmo no app
            setInterval(() => {
                checkReminders();
            }, 30000); // A cada 30 segundos
            
            console.log('üíö Keep-Alive iniciado (intervalos reduzidos)');
        }

        // Registrar Background Sync para manter SW ativo
        async function registerBackgroundSync() {
            if ('serviceWorker' in navigator && 'sync' in self.registration) {
                try {
                    const registration = await navigator.serviceWorker.ready;
                    await registration.sync.register('check-reminders');
                    console.log('‚úÖ Background Sync registrado');
                } catch (err) {
                    console.log('‚ùå Background Sync n√£o suportado:', err);
                }
            }
            
            // Tentar registrar Periodic Background Sync
            if ('serviceWorker' in navigator && 'periodicSync' in self.registration) {
                try {
                    const registration = await navigator.serviceWorker.ready;
                    const status = await navigator.permissions.query({
                        name: 'periodic-background-sync',
                    });
                    
                    if (status.state === 'granted') {
                        await registration.periodicSync.register('check-reminders-periodic', {
                            minInterval: 15 * 60 * 1000, // 15 minutos
                        });
                        console.log('‚úÖ Periodic Background Sync registrado (15min)');
                    }
                } catch (err) {
                    console.log('‚ùå Periodic Background Sync n√£o suportado:', err);
                }
            }
        }

        // Manter tela acordada (opcional, mas ajuda)
        let wakeLock = null;
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('üî¶ Wake Lock ativado (tela permanecer√° ligada)');
                    
                    wakeLock.addEventListener('release', () => {
                        console.log('üî¶ Wake Lock liberado');
                    });
                } catch (err) {
                    console.log('‚ùå Wake Lock n√£o dispon√≠vel:', err);
                }
            }
        }

        // Re-adquirir wake lock quando a p√°gina fica vis√≠vel
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // Inicializar
        window.onload = function() {
            console.log('üöÄ Aplicativo iniciado');
            loadReminders();
            requestNotificationPermission();
            
            // Verificar lembretes a cada 5 segundos para maior precis√£o
            console.log('‚è∞ Verifica√ß√£o autom√°tica configurada (5s)');
            checkInterval = setInterval(checkReminders, 5000);
            
            // Verificar imediatamente ao carregar
            checkReminders();
            
            // Enviar lembretes para o service worker a cada 30 segundos
            setInterval(sendRemindersToServiceWorker, 30000);
            
            // Enviar lembretes inicialmente ap√≥s 2 segundos
            setTimeout(sendRemindersToServiceWorker, 2000);
            
            // Definir data/hora m√≠nima como agora
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            document.getElementById('reminderTime').min = now.toISOString().slice(0, 16);
            document.getElementById('intervalStart').min = now.toISOString().slice(0, 16);
            document.getElementById('modalTime').min = now.toISOString().slice(0, 16);
            
            // Renderizar lista inicial vazia
            renderMainSchedulesList();
            
            // Inicializar visualiza√ß√£o de agendamento
            toggleScheduleType();
            
            // Iniciar sistemas de sobreviv√™ncia em segundo plano
            startKeepAlive();
            registerBackgroundSync();
            
            // Solicitar Wake Lock (ATIVADO por padr√£o para confiabilidade)
            // IMPORTANTE: Mant√©m a tela ligada e o app ativo em segundo plano
            requestWakeLock();
            
            console.log('üî¶ Wake Lock ativado automaticamente');
        };
    </script>
</body>
</html>
